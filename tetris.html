<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Tetris</title>
    <style>
        :root {
            --bg: #0a0a12;
            --panel: #12121b;
            --fg: #eef1ff;
            --accent: #ff2f6d;
        }
        html, body {
            height: 100%;
            margin: 0;
            /* Soft radial gradient background with subtle vignette */
            background: radial-gradient(1200px 800px at 20% 10%, #121226 0%, #0b0b14 55%, #05050a 100%);
            color: var(--fg);
            font-family: "Courier New", monospace;
        }
        .wrap {
            min-height: 100%;
            display: grid;
            place-items: center;
            padding: 20px;
        }
        .game {
            background: linear-gradient(180deg, rgba(18,18,27,0.95), rgba(18,18,27,0.85));
            border: 1px solid rgba(255,47,109,0.35);
            border-radius: 10px;
            padding: 14px;
            display: grid;
            grid-template-columns: auto 180px;
            gap: 14px;
            box-shadow:
                0 10px 30px rgba(0,0,0,0.45),
                0 0 0 2px rgba(255,47,109,0.08) inset,
                0 0 24px rgba(255,47,109,0.12);
        }
        canvas {
            background: #000;
            image-rendering: pixelated;
            width: min(90vw, 360px);
            height: calc(min(90vw, 360px) * 2);
            max-width: 360px;
            max-height: 720px;
            border-radius: 8px;
            box-shadow:
                0 20px 40px rgba(0,0,0,0.45),
                0 0 0 1px rgba(255,255,255,0.04) inset,
                0 0 48px rgba(255,47,109,0.08);
        }
        .side {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 160px;
        }
        .info {
            border: 1px solid rgba(255,47,109,0.35);
            padding: 10px;
            border-radius: 8px;
            background: linear-gradient(180deg, #0f0f18 0%, #0e0e16 100%);
            font-size: 14px;
            line-height: 1.45;
            box-shadow:
                0 10px 22px rgba(0,0,0,0.3),
                0 0 0 1px rgba(255,255,255,0.03) inset;
        }
        .title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 6px;
            text-shadow: 0 0 8px rgba(255,47,109,0.35);
            letter-spacing: 0.5px;
        }
        .btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        a.btn {
            color: #0a0a12;
            background: linear-gradient(180deg, #ff6a9a, #ff2f6d);
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            box-shadow:
                0 8px 18px rgba(255,47,109,0.35),
                0 0 0 1px rgba(255,255,255,0.08) inset;
            transition: transform .08s ease, filter .08s ease;
        }
        a.btn:hover { filter: brightness(1.05); transform: translateY(-1px); }
        .muted { opacity: 0.8; }
        @media (max-width: 640px) {
            .game { grid-template-columns: 1fr; }
            .side { order: -1; }
        }

        /* Mobile controls */
        .touch-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        .touch-controls .row {
            display: contents;
        }
        .touch-controls button {
            background: linear-gradient(180deg, #ff6a9a, #ff2f6d);
            color: #0a0a12;
            border: none;
            border-radius: 8px;
            padding: 10px 12px;
            font-weight: bold;
            font-family: "Courier New", monospace;
            cursor: pointer;
            user-select: none;
            box-shadow:
                0 8px 18px rgba(255,47,109,0.35),
                0 0 0 1px rgba(255,255,255,0.08) inset;
            transition: transform .06s ease, filter .06s ease;
        }
        .touch-controls button:active { filter: brightness(0.95); transform: translateY(1px); }
        @media (max-width: 640px) {
            .touch-controls { display: grid; }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="game">
        <canvas id="tetris" width="240" height="480" aria-label="Tetris board"></canvas>
        <div class="side">
            <div class="info">
                <div class="title">Tetris</div>
                <div>Score: <span id="score">0</span></div>
                <div>Lines: <span id="lines">0</span></div>
                <div>Level: <span id="level">0</span></div>
            </div>
            <div class="info">
                <div class="title">Controls</div>
                <div>A: Move left</div>
                <div>D: Move right</div>
                <div>R: Rotate</div>
                <div>S: Soft drop</div>
                <div>Space: Hard drop</div>
                <div>M: Restart</div>
                <div>P: Pause</div>
                <div class="muted">Esc: Back</div>
            </div>

            <!-- Mobile controls -->
            <div class="touch-controls" aria-label="Mobile Controls">
                <div class="row">
                    <button data-action="left">←</button>
                    <button data-action="rotate">⟳</button>
                    <button data-action="right">→</button>
                </div>
                <div class="row">
                    <button data-action="soft">Soft</button>
                    <button data-action="hard">Hard</button>
                    <button data-action="pause">Pause</button>
                </div>
                <div class="row">
                    <button data-action="restart">Restart</button>
                    <button data-action="back">Back</button>
                    <span></span>
                </div>
            </div>

            <div class="btns">
                <a class="btn" href="index.html">Back</a>
            </div>
        </div>
    </div>
</div>

<script>
  // admin guard: redirect to index if not admin
  // launch-token guard: only allow if launched from terminal (short-lived token)
  (function(){
    try {
      const params = new URLSearchParams(window.location.search);
      const token = params.get('lt');
      const stored = sessionStorage.getItem('alpha_launch_token');
      const expiry = parseInt(sessionStorage.getItem('alpha_launch_expiry') || '0', 10);
      if (!token || !stored || token !== stored || Date.now() > expiry) {
        alert('Access denied. Game must be launched from the terminal.');
        window.location.href = 'index.html';
        return;
      }
      // consume token and clean URL
      sessionStorage.removeItem('alpha_launch_token');
      sessionStorage.removeItem('alpha_launch_expiry');
      const url = new URL(window.location);
      url.searchParams.delete('lt');
      window.history.replaceState({}, '', url.pathname + url.search + url.hash);
    } catch(e) {
      window.location.href = 'index.html';
      return;
    }
  })();

  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');

  const COLS = 10, ROWS = 20, SIZE = 24;
  ctx.scale(SIZE/24, SIZE/24); // keep logical pixels at 24px blocks

  // ----- Visual helpers -----
  function hexToRgb(hex) {
      const n = parseInt(hex.slice(1), 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
  }
  function clamp(v, lo=0, hi=255) { return Math.max(lo, Math.min(hi, v)); }
  function rgbToHex(r,g,b) {
      return '#' + [r,g,b].map(v => clamp(v).toString(16).padStart(2,'0')).join('');
  }
  function adjustColor(hex, amt) {
      const {r,g,b} = hexToRgb(hex);
      return rgbToHex(r + amt, g + amt, b + amt);
  }
  function rgba(hex, a) {
      const {r,g,b} = hexToRgb(hex);
      return `rgba(${r},${g},${b},${a})`;
  }

  function drawBlock(px, py, color) {
      // glossy gradient fill
      const g = ctx.createLinearGradient(px, py, px + 24, py + 24);
      g.addColorStop(0.0, adjustColor(color, 60));
      g.addColorStop(0.55, color);
      g.addColorStop(1.0, adjustColor(color, -40));
      ctx.fillStyle = g;
      ctx.fillRect(px, py, 24, 24);

      // inner highlight
      ctx.fillStyle = 'rgba(255,255,255,0.09)';
      ctx.fillRect(px + 3, py + 3, 18, 6);

      // bevel edges (light top/left, dark bottom/right)
      ctx.beginPath();
      ctx.moveTo(px+0.5, py+23.5); ctx.lineTo(px+0.5, py+0.5); ctx.lineTo(px+23.5, py+0.5);
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(px+23.5, py+0.5); ctx.lineTo(px+23.5, py+23.5); ctx.lineTo(px+0.5, py+23.5);
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.stroke();
  }

  function drawGrid() {
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      for (let x = 1; x < COLS; x++) {
          const px = x * 24 + 0.5;
          ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, ROWS * 24); ctx.stroke();
      }
      for (let y = 1; y < ROWS; y++) {
          const py = y * 24 + 0.5;
          ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(COLS * 24, py); ctx.stroke();
      }
      ctx.restore();
  }

  function drawBackground() {
      // vertical gradient
      const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bg.addColorStop(0, '#0a0a12');
      bg.addColorStop(1, '#04040a');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // soft vignette glow
      const rg = ctx.createRadialGradient(canvas.width*0.3, canvas.height*0.18, 12, canvas.width*0.3, canvas.height*0.18, canvas.height*0.8);
      rg.addColorStop(0, 'rgba(255,47,109,0.10)');
      rg.addColorStop(1, 'rgba(255,47,109,0.00)');
      ctx.fillStyle = rg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid();
  }

  function createMatrix(w, h) {
      const m = [];
      while (h--) m.push(new Array(w).fill(0));
      return m;
  }

  function createPiece(type) {
      switch (type) {
          case 'T': return [
              [0,1,0],
              [1,1,1],
              [0,0,0],
          ];
          case 'O': return [
              [2,2],
              [2,2],
          ];
          case 'L': return [
              [0,0,3],
              [3,3,3],
              [0,0,0],
          ];
          case 'J': return [
              [4,0,0],
              [4,4,4],
              [0,0,0],
          ];
          case 'I': return [
              [0,0,0,0],
              [5,5,5,5],
              [0,0,0,0],
              [0,0,0,0],
          ];
          case 'S': return [
              [0,6,6],
              [6,6,0],
              [0,0,0],
          ];
          case 'Z': return [
              [7,7,0],
              [0,7,7],
              [0,0,0],
          ];
      }
  }

  const colors = [
      null,
      '#a000f0', // T
      '#f0f000', // O
      '#f0a000', // L
      '#0000f0', // J
      '#00f0f0', // I
      '#00f000', // S
      '#f00000', // Z
  ];

  const arena = createMatrix(COLS, ROWS);

  const player = {
      pos: { x: 0, y: 0 },
      matrix: null,
      score: 0,
      lines: 0,
      level: 0,
  };

  let dropCounter = 0;
  let lastTime = 0;
  let paused = false;

  // Flash animation state for line clear
  let flashingRows = [];
  let flashElapsed = 0;
  const FLASH_DURATION = 200;   // total flash time in ms
  const FLASH_INTERVAL = 80;    // toggle interval in ms

  // Visual extras
  let pieceSpawnT = 0;
  const PIECE_SPAWN_MS = 140;
  let clearColors = []; // snapshot of colors for flashing rows

  // Simple particle system for line clears
  const particles = [];
  function emitLineClearParticles(rows, colorRows) {
      for (let i = 0; i < rows.length; i++) {
          const y = rows[i];
          const rowColors = colorRows[i] || [];
          for (let x = 0; x < COLS; x++) {
              const c = rowColors[x] || '#ffffff';
              // spawn a couple particles per cell
              for (let k = 0; k < 2; k++) {
                  const cx = x * 24 + 12;
                  const cy = y * 24 + 12;
                  const ang = (Math.random() * Math.PI) - Math.PI/2; // mostly sideways
                  const spd = 1.2 + Math.random() * 2.2;
                  particles.push({
                      x: cx, y: cy,
                      vx: Math.cos(ang) * spd,
                      vy: Math.sin(ang) * spd - (0.5 + Math.random()*0.6),
                      life: 520 + Math.random()*200,
                      age: 0,
                      color: c,
                      size: 2 + Math.random()*1.5,
                  });
              }
          }
      }
  }
  function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.age += dt;
          if (p.age >= p.life) { particles.splice(i,1); continue; }
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.03; // gravity
      }
  }
  function drawParticles() {
      for (const p of particles) {
          const a = 1 - (p.age / p.life);
          ctx.fillStyle = rgba(p.color, Math.max(0, a*0.9));
          ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
      }
  }

  function collide(arena, player) {
      const m = player.matrix;
      const o = player.pos;
      for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
              if (m[y][x] !== 0 &&
                  (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  // Collision check for arbitrary position (used by ghost)
  function collideAt(matrix, pos) {
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < matrix[y].length; ++x) {
              if (matrix[y][x] !== 0 &&
                  (arena[y + pos.y] && arena[y + pos.y][x + pos.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  function merge(arena, player) {
      player.matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) arena[y + player.pos.y][x + player.pos.x] = v;
          });
      });
  }

  function rotate(matrix, dir) {
      // transpose
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < y; ++x) {
              [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
          }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
  }

  function playerReset() {
      const pieces = 'TJLOSZI';
      player.matrix = createPiece(pieces[(pieces.length * Math.random()) | 0]);
      player.pos.y = 0;
      player.pos.x = ((COLS / 2) | 0) - ((player.matrix[0].length / 2) | 0);
      // start spawn pop animation
      pieceSpawnT = PIECE_SPAWN_MS;
      if (collide(arena, player)) {
          arena.forEach(row => row.fill(0));
          player.score = 0;
          player.lines = 0;
          player.level = 0;
          updateScore();
      }
  }

  function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
  }

  function getFullRows() {
      const rows = [];
      for (let y = 0; y < arena.length; ++y) {
          let full = true;
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) { full = false; break; }
          }
          if (full) rows.push(y);
      }
      return rows;
  }

  function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          const rows = getFullRows();
          if (rows.length) {
              // Snapshot colors for particles before we start flashing
              clearColors = rows.map(y => arena[y].map(v => colors[v] || '#ffffff'));
              // Start flash; actual clear happens after flash
              flashingRows = rows;
              flashElapsed = 0;
          } else {
              playerReset();
          }
      }
      dropCounter = 0;
  }

  function hardDrop() {
      do {
          player.pos.y++;
      } while (!collide(arena, player));
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      playerReset();
      dropCounter = 0;
  }

  function playerRotate(dir) {
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > player.matrix[0].length) {
              rotate(player.matrix, -dir);
              player.pos.x = pos;
              return;
          }
      }
  }

  function arenaSweep() {
      let rowCount = 1;
      outer: for (let y = arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) continue outer;
          }
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          player.score += rowCount * 100;
          player.lines += 1;
          if (player.lines % 10 === 0) player.level++;
          rowCount *= 2;
      }
      updateScore();
  }

  // Enhanced drawMatrix with styles: 'solid' | 'ghost' | 'shadow'
  function drawMatrix(matrix, offset, style = 'solid') {
      matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v === 0) return;
              const px = (x + offset.x) * 24;
              const py = (y + offset.y) * 24;
              if (style === 'solid') {
                  drawBlock(px, py, colors[v]);
              } else if (style === 'shadow') {
                  ctx.fillStyle = 'rgba(0,0,0,0.25)';
                  ctx.fillRect(px + 2, py + 2, 24, 24);
              } else if (style === 'ghost') {
                  ctx.save();
                  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
                  ctx.setLineDash([4, 4]);
                  ctx.lineWidth = 1;
                  ctx.strokeRect(px + 0.5, py + 0.5, 23, 23);
                  ctx.restore();
              }
          });
      });
  }

  // Compute ghost landing Y for current piece
  function getGhostY() {
      let y = player.pos.y;
      while (!collideAt(player.matrix, { x: player.pos.x, y: y + 1 })) {
          y++;
      }
      return y;
  }

  function draw() {
      // Background and grid
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();

      // Arena
      drawMatrix(arena, { x: 0, y: 0 }, 'solid');

      // Draw ghost only when piece is active (not flashing)
      if (!flashingRows.length) {
          const gy = getGhostY();
          drawMatrix(player.matrix, { x: player.pos.x, y: gy }, 'ghost');

          // Drop shadow then the piece with a tiny spawn pop
          drawMatrix(player.matrix, player.pos, 'shadow');
          ctx.save();
          // spawn pop scale
          const t = Math.max(0, Math.min(1, 1 - (pieceSpawnT / PIECE_SPAWN_MS)));
          const s = 0.94 + 0.06 * t;
          const cx = (player.pos.x + player.matrix[0].length / 2) * 24;
          const cy = (player.pos.y + player.matrix.length / 2) * 24;
          ctx.translate(cx, cy);
          ctx.scale(s, s);
          ctx.translate(-cx, -cy);
          drawMatrix(player.matrix, player.pos, 'solid');
          ctx.restore();
      }

      // Particles (above blocks)
      drawParticles();

      // Pause indicator overlay
      if (paused) {
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#ff2f6d';
          ctx.font = 'bold 28px "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(255,47,109,0.5)';
          ctx.shadowBlur = 16;
          ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
          ctx.shadowBlur = 0;
      }

      // Flash rows that will be cleared
      if (flashingRows.length) {
          const on = Math.floor(flashElapsed / FLASH_INTERVAL) % 2 === 0;
          if (on) {
              ctx.save();
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = '#ffffff';
              for (const y of flashingRows) {
                  ctx.fillRect(0, y * 24, canvas.width, 24);
              }
              ctx.restore();
          }
      }
  }

  function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;

      if (!paused) {
          if (flashingRows.length) {
              // Run flash animation; defer clearing until done
              flashElapsed += delta;
              if (flashElapsed >= FLASH_DURATION) {
                  // particle burst before we mutate arena
                  emitLineClearParticles(flashingRows, clearColors);
                  flashingRows = [];
                  clearColors = [];
                  arenaSweep();      // clears and updates score/lines/level
                  playerReset();     // spawn next piece
              }
          } else {
              dropCounter += delta;
              const speed = Math.max(120, 1000 - player.level * 75);
              if (dropCounter > speed) playerDrop();
          }
          // Visual timers
          if (pieceSpawnT > 0) pieceSpawnT -= delta;
          updateParticles(delta);
      }

      draw();
      requestAnimationFrame(update);
  }

  function updateScore() {
      document.getElementById('score').textContent = player.score;
      document.getElementById('lines').textContent = player.lines;
      document.getElementById('level').textContent = player.level;
  }

  document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();

      // Ignore inputs during line-flash except Esc
      if (flashingRows.length && k !== 'escape') {
          e.preventDefault();
          return;
      }

      // When paused, only allow pause toggle and escape
      if (paused && k !== 'p' && k !== 'escape') {
          e.preventDefault();
          return;
      }

      if (k === 'a') { e.preventDefault(); playerMove(-1); }
      else if (k === 'd') { e.preventDefault(); playerMove(1); }
      else if (k === 's') { e.preventDefault(); playerDrop(); }
      else if (k === 'r') { e.preventDefault(); playerRotate(1); }
      else if (k === ' ') { e.preventDefault(); hardDrop(); }
      else if (k === 'm') {
          e.preventDefault();
          arena.forEach(row => row.fill(0));
          player.score = 0; player.lines = 0; player.level = 0;
          playerReset(); updateScore();
      }
      else if (k === 'p') { e.preventDefault(); paused = !paused; }
      else if (k === 'escape') { window.location.href = 'index.html'; }
  });

  // Mobile buttons hook
  (function wireTouchControls(){
      const actions = {
          left: () => playerMove(-1),
          right: () => playerMove(1),
          rotate: () => playerRotate(1),
          soft: () => playerDrop(),
          hard: () => hardDrop(),
          pause: () => { paused = !paused; },
          restart: () => {
              arena.forEach(row => row.fill(0));
              player.score = 0; player.lines = 0; player.level = 0;
              playerReset(); updateScore();
          },
          back: () => { window.location.href = 'index.html'; }
      };
      document.querySelectorAll('.touch-controls button').forEach(btn => {
          btn.addEventListener('click', () => {
              const act = btn.getAttribute('data-action');
              // Ignore touch actions during flash except Back
              if (flashingRows.length && act !== 'back') return;
              // When paused, only allow pause toggle and back
              if (paused && act !== 'pause' && act !== 'back') return;
              if (actions[act]) actions[act]();
          }, { passive: true });
      });
  })();

  playerReset();
  updateScore();
  update();
</script>
</body>
</html>
