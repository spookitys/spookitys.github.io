<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Tetris</title>
    <style>
        :root {
            --bg: #090a10;
            --bg2: #0c0f1a;
            --panel: #10121fcc;
            --fg: #f6f7ff;
            --accent: #ff3040;
            --glow: #ff4055;
        }
        html, body {
            height: 100%;
            margin: 0;
            background: radial-gradient(1200px 800px at 20% 10%, #111428, var(--bg)) fixed,
                        radial-gradient(900px 900px at 80% 100%, #0a0d20, var(--bg2)) fixed;
            color: var(--fg);
            font-family: "Courier New", monospace;
        }
        .wrap {
            min-height: 100%;
            display: grid;
            place-items: center;
            padding: 20px;
        }
        .game {
            background: linear-gradient(180deg, #0e1120cc, #0a0d18cc);
            border: 1px solid rgba(255, 64, 85, 0.35);
            border-radius: 12px;
            padding: 14px;
            box-shadow:
              0 0 0 1px rgba(255, 64, 85, 0.2) inset,
              0 10px 30px rgba(0,0,0,0.6),
              0 0 30px rgba(255, 64, 85, 0.15);
            backdrop-filter: blur(6px);
            display: grid;
            grid-template-columns: auto 200px;
            gap: 14px;
        }
        canvas {
            background: transparent; /* background drawn in canvas now */
            image-rendering: pixelated;
            border-radius: 10px;
            box-shadow:
              0 0 0 1px rgba(255,255,255,0.06) inset,
              0 10px 30px rgba(0,0,0,0.5),
              0 0 40px rgba(255, 64, 85, 0.12);
            width: min(90vw, 360px);
            height: calc(min(90vw, 360px) * 2);
            max-width: 360px;
            max-height: 720px;
        }
        .side {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 180px;
        }
        .info {
            border: 1px solid rgba(255,255,255,0.08);
            padding: 10px;
            border-radius: 10px;
            background: linear-gradient(180deg, #0f1222, #0d1020);
            box-shadow: 0 6px 16px rgba(0,0,0,0.35), 0 0 20px rgba(255, 64, 85, 0.08) inset;
            font-size: 14px;
        }
        .title {
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(255,48,64,0.35);
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        a.btn {
            color: #0b0d16;
            background: linear-gradient(180deg, #ff5a6a, #ff3040);
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow:
              0 6px 16px rgba(255,48,64,0.35),
              0 0 0 1px rgba(255,255,255,0.1) inset;
            transition: transform .08s ease, filter .08s ease;
        }
        a.btn:hover { filter: brightness(1.05); transform: translateY(-1px); }
        .muted { opacity: 0.8; }
        .small { font-size: 12px; opacity: 0.7; margin-top: 4px; }

        @media (max-width: 640px) {
            .game { grid-template-columns: 1fr; }
            .side { order: -1; }
        }

        /* Mobile controls */
        .touch-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        .touch-controls .row {
            display: contents;
        }
        .touch-controls button {
            background: linear-gradient(180deg, #ff6d7a, #ff3040);
            color: #0b0d16;
            border: none;
            border-radius: 10px;
            padding: 10px 12px;
            font-weight: bold;
            font-family: "Courier New", monospace;
            cursor: pointer;
            user-select: none;
            box-shadow:
              0 8px 18px rgba(255,48,64,0.35),
              0 0 0 1px rgba(255,255,255,0.1) inset;
            transition: transform .06s ease, filter .06s ease;
        }
        .touch-controls button:active { filter: brightness(0.92); transform: translateY(1px); }
        @media (max-width: 640px) {
            .touch-controls { display: grid; }
        }

        /* Subtle animated scanlines overlay */
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
              repeating-linear-gradient(
                to bottom,
                rgba(255,255,255,0.04),
                rgba(255,255,255,0.04) 1px,
                transparent 3px,
                transparent 4px
              );
            mix-blend-mode: soft-light;
            animation: sl 6s linear infinite;
        }
        @keyframes sl {
            from { transform: translateY(0); }
            to   { transform: translateY(4px); }
        }

        /* Small preview canvas styling */
        #next {
            width: 96px;
            height: 96px;
            image-rendering: pixelated;
            border-radius: 8px;
            background: linear-gradient(180deg, #0f1222, #0d1020);
            box-shadow:
              0 6px 16px rgba(0,0,0,0.35),
              0 0 10px rgba(255,64,85,0.04) inset;
        }

        /* Start screen / mode buttons */
        .start-modes {
            display: flex;
            gap: 8px;
        }
        .mode {
            flex: 1;
            text-align: center;
        }
        .mode-btn {
            width: 100%;
            background: linear-gradient(180deg, #fff 0%, #ffd0d5 100%);
            border-radius: 8px;
            padding: 8px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            color: #0b0d16;
            box-shadow: 0 6px 18px rgba(255,48,64,0.15);
        }
        .start-overlay, .end-overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            pointer-events: none;
        }
        .overlay-panel {
            pointer-events: auto;
            background: linear-gradient(180deg,#0c0f1aee,#0b0d16cc);
            padding: 18px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.06);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            text-align: center;
            min-width: 260px;
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="game" style="position:relative;">
        <canvas id="tetris" width="240" height="480" aria-label="Tetris board"></canvas>

        <!-- Start overlay (initial) -->
        <div id="startOverlay" class="start-overlay" aria-hidden="true" style="display:none;">
            <div class="overlay-panel">
                <div class="title">Choose Mode</div>
                <div class="start-modes" style="margin-bottom:10px;">
                    <div class="mode">
                        <button class="mode-btn" data-mode="classic">Classic</button>
                        <div class="small muted">The classic Tetris experience!<br><span class="muted small">(1x speed, 1x scaling, 1x points)</span></div>
                    </div>
                    <div class="mode">
                        <button class="mode-btn" data-mode="hard">Hard</button>
                        <div class="small muted">For more experienced players<br><span class="muted small">(2x speed, 2x scaling, 1.5x points)</span></div>
                    </div>
                    <div class="mode">
                        <button class="mode-btn" data-mode="ability">Ability</button>
                        <div class="small muted">For a chaotic and fun time!<br><span class="muted small">(1.5x speed, 1.5x scaling, 0.5x points)</span></div>
                    </div>
                </div>
                <div class="muted small">Select a mode to begin</div>
            </div>
        </div>

        <!-- End overlay -->
        <div id="endOverlay" class="end-overlay" aria-hidden="true" style="display:none;">
            <div class="overlay-panel">
                <div class="title">Game Over</div>
                <div>Final Score: <span id="finalScore">0</span></div>
                <div style="margin-top:10px;">
                    <button id="playAgain" class="mode-btn" style="width:120px;">Play Again</button>
                </div>
            </div>
        </div>

        <div class="side">
            <div class="info">
                <div class="title">Tetris</div>
                <div>Score: <span id="score">0</span></div>
                <!-- Lines and Level removed per request -->
            </div>
            <div class="info">
                <div class="title">Controls</div>
                <div>A: Move left</div>
                <div>D: Move right</div>
                <div>R: Rotate</div>
                <div>S: Soft drop</div>
                <div>Space: Hard drop</div>
                <div>M: Restart</div>
                <div>P: Pause</div>
                <div class="muted">Esc: Back</div>
            </div>

            <!-- Next piece preview -->
            <div class="info">
                <div class="title">Next</div>
                <canvas id="next" width="96" height="96" aria-label="Next piece preview"></canvas>
            </div>

            <!-- Mobile controls -->
            <div class="touch-controls" aria-label="Mobile Controls">
                <div class="row">
                    <button data-action="left">←</button>
                    <button data-action="rotate">⟳</button>
                    <button data-action="right">→</button>
                </div>
                <div class="row">
                    <button data-action="soft">Soft</button>
                    <button data-action="hard">Hard</button>
                    <button data-action="pause">Pause</button>
                </div>
                <div class="row">
                    <button data-action="restart">Restart</button>
                    <button data-action="back">Back</button>
                    <span></span>
                </div>
            </div>

            <div class="btns">
                <a class="btn" href="index.html">Back</a>
            </div>
        </div>
    </div>
</div>

<script>
  // admin guard: redirect to index if not admin
  // launch-token guard: only allow if launched from terminal (short-lived token)
  (function(){
    try {
      const params = new URLSearchParams(window.location.search);
      const token = params.get('lt');
      const stored = sessionStorage.getItem('alpha_launch_token');
      const expiry = parseInt(sessionStorage.getItem('alpha_launch_expiry') || '0', 10);
      if (!token || !stored || token !== stored || Date.now() > expiry) {
        alert('Access denied. Game must be launched from the terminal.');
        window.location.href = 'index.html';
        return;
      }
      // consume token and clean URL
      sessionStorage.removeItem('alpha_launch_token');
      sessionStorage.removeItem('alpha_launch_expiry');
      const url = new URL(window.location);
      url.searchParams.delete('lt');
      window.history.replaceState({}, '', url.pathname + url.search + url.hash);
    } catch(e) {
      window.location.href = 'index.html';
      return;
    }
  })();

  const canvas = document.getElementById('tetris');
  let ctx = canvas.getContext('2d');

  // New: preview canvas/context
  const nextCanvas = document.getElementById('next');
  let nctx = nextCanvas.getContext('2d');

  const COLS = 10, ROWS = 20;
  let CELL = 24; // will be modified by chosen mode

  // Visual/FX state
  const particles = [];
  let nowMs = 0;

  function createMatrix(w, h) {
      const m = [];
      while (h--) m.push(new Array(w).fill(0));
      return m;
  }

  function createPiece(type) {
      switch (type) {
          case 'T': return [
              [0,1,0],
              [1,1,1],
              [0,0,0],
          ];
          case 'O': return [
              [2,2],
              [2,2],
          ];
          case 'L': return [
              [0,0,3],
              [3,3,3],
              [0,0,0],
          ];
          case 'J': return [
              [4,0,0],
              [4,4,4],
              [0,0,0],
          ];
          case 'I': return [
              [0,0,0,0],
              [5,5,5,5],
              [0,0,0,0],
              [0,0,0,0],
          ];
          case 'S': return [
              [0,6,6],
              [6,6,0],
              [0,0,0],
          ];
          case 'Z': return [
              [7,7,0],
              [0,7,7],
              [0,0,0],
          ];
      }
  }

  const colors = [
      null,
      '#a000f0', // T
      '#f0f000', // O
      '#f0a000', // L
      '#0000f0', // J
      '#00f0f0', // I
      '#00f000', // S
      '#f00000', // Z
  ];

  const arena = createMatrix(COLS, ROWS);

  const player = {
      pos: { x: 0, y: 0 },
      matrix: null,
      score: 0
  };

  let dropCounter = 0;
  let lastTime = 0;
  let paused = true;     // start paused until mode selected
  let gameStarted = false;

  // Flash animation state for line clear
  let flashingRows = [];
  let flashElapsed = 0;
  const FLASH_DURATION = 200;   // total flash time in ms
  const FLASH_INTERVAL = 80;    // toggle interval in ms

  // current game mode multipliers
  const modes = {
      classic: { speed: 1.0, scale: 1.0, points: 1.0 },
      hard:    { speed: 2.0, scale: 2.0, points: 1.5 },
      ability: { speed: 1.5, scale: 1.5, points: 0.5 }
  };
  let gameMode = modes.classic;

  function collide(arena, player) {
      const m = player.matrix;
      const o = player.pos;
      for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
              if (m[y][x] !== 0 &&
                  (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  // Collision check for arbitrary position (used by ghost)
  function collideAt(matrix, pos) {
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < matrix[y].length; ++x) {
              if (matrix[y][x] !== 0 &&
                  (arena[y + pos.y] && arena[y + pos.y][x + pos.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  function merge(arena, player) {
      player.matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) arena[y + player.pos.y][x + player.pos.x] = v;
          });
      });
  }

  function rotate(matrix, dir) {
      // transpose
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < y; ++x) {
              [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
          }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
  }

  // Adjusted playerReset to use/produce a nextPiece (queue of 1)
  function playerReset() {
      const pieces = 'TJLOSZI';
      // current becomes previously queued next if available, otherwise random
      if (nextPiece) {
          player.matrix = nextPiece;
      } else {
          player.matrix = createPiece(pieces[(pieces.length * Math.random()) | 0]);
      }
      // queue the next piece
      nextPiece = createPiece(pieces[(pieces.length * Math.random()) | 0]);
      drawNext();

      player.pos.y = 0;
      player.pos.x = ((COLS / 2) | 0) - ((player.matrix[0].length / 2) | 0);
      if (collide(arena, player)) {
          // Game over: show end screen (preserve final score)
          showEndScreen();
          return;
      }
  }

  function playerMove(dir) {
      if (!gameStarted || paused) return;
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
  }

  function getFullRows() {
      const rows = [];
      for (let y = 0; y < arena.length; ++y) {
          let full = true;
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) { full = false; break; }
          }
          if (full) rows.push(y);
      }
      return rows;
  }

  function playerDrop() {
      if (!gameStarted || paused) return;
      player.pos.y++;
      if (collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          const rows = getFullRows();
          if (rows.length) {
              flashingRows = rows;
              flashElapsed = 0;
              spawnLineParticles(rows);
          } else {
              playerReset();
          }
      }
      dropCounter = 0;
  }

  function hardDrop() {
      if (!gameStarted || paused) return;
      do {
          player.pos.y++;
      } while (!collide(arena, player));
      player.pos.y--;
      merge(arena, player);
      spawnPieceBurst(player); // visual only
      arenaSweep();
      playerReset();
      dropCounter = 0;
  }

  function playerRotate(dir) {
      if (!gameStarted || paused) return;
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > player.matrix[0].length) {
              rotate(player.matrix, -dir);
              player.pos.x = pos;
              return;
          }
      }
  }

  function arenaSweep() {
      let rowCount = 1;
      outer: for (let y = arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) continue outer;
          }
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          player.score += Math.round(rowCount * 100 * gameMode.points);
          rowCount *= 2;
      }
      updateScore();
  }

  // Reduce block glow drastically: subtle neutral shadow instead of strong colored glow
  function drawCell(px, py, color, opts = {}) {
      const { ghost = false } = opts;
      const x = px * CELL, y = py * CELL;

      if (!ghost) {
          ctx.shadowBlur = 1;
          ctx.shadowColor = 'rgba(0,0,0,0.12)';
      } else {
          ctx.shadowBlur = 0;
      }

      // base
      ctx.fillStyle = color;
      ctx.fillRect(x, y, CELL, CELL);

      // glossy overlay
      const g = ctx.createLinearGradient(x, y, x, y + CELL);
      g.addColorStop(0, 'rgba(255,255,255,0.28)');
      g.addColorStop(0.4, 'rgba(255,255,255,0.08)');
      g.addColorStop(1, 'rgba(0,0,0,0.3)');
      ctx.fillStyle = g;
      ctx.fillRect(x, y, CELL, CELL);

      // border
      ctx.lineWidth = 1;
      ctx.strokeStyle = ghost ? 'rgba(255,255,255,0.35)' : 'rgba(0,0,0,0.55)';
      ctx.strokeRect(x + 0.5, y + 0.5, CELL - 1, CELL - 1);

      // reset shadow
      ctx.shadowBlur = 0;
  }

  function drawMatrix(matrix, offset, opts = {}) {
      matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) {
                  const color = colors[v];
                  if (opts.ghost) {
                      ctx.save();
                      ctx.globalAlpha = 0.22;
                      drawCell(x + offset.x, y + offset.y, '#ffffff', { ghost: true });
                      ctx.restore();
                  } else {
                      drawCell(x + offset.x, y + offset.y, color);
                  }
              }
          });
      });
  }

  // Subtle grid
  function drawGrid() {
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * CELL + 0.5, 0);
          ctx.lineTo(x * CELL + 0.5, ROWS * CELL);
          ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL + 0.5);
          ctx.lineTo(COLS * CELL, y * CELL + 0.5);
          ctx.stroke();
      }
      ctx.restore();
  }

  // Animated background inside canvas
  function drawBackground(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w * 0.5 + Math.sin(t * 0.0004) * 40;
      const cy = h * 0.35 + Math.cos(t * 0.0005) * 30;

      const rg = ctx.createRadialGradient(cx, cy, 20, w*0.5, h*0.6, Math.max(w,h));
      rg.addColorStop(0, 'rgba(255,64,85,0.03)');
      rg.addColorStop(0.45, 'rgba(30,36,66,0.85)');
      rg.addColorStop(1, 'rgba(5,7,14,1)');

      ctx.fillStyle = rg;
      ctx.fillRect(0, 0, w, h);

      // floating vignette
      ctx.save();
      ctx.globalCompositeOperation = 'soft-light';
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      const off = (t * 0.03) % CELL;
      for (let y = -CELL + off; y < h; y += CELL) {
          ctx.fillRect(0, y, w, 2);
      }
      ctx.restore();
    }

  // Ghost Y stays the same
  function getGhostY() {
      let y = player.pos.y;
      while (!collideAt(player.matrix, { x: player.pos.x, y: y + 1 })) {
          y++;
      }
      return y;
  }

  // Particles
  function spawnLineParticles(rows) {
      const cellSize = CELL;
      rows.forEach((ry) => {
          for (let i = 0; i < COLS * 2; i++) {
              const x = (Math.random() * COLS) * cellSize + cellSize * 0.5;
              const y = ry * cellSize + cellSize * 0.5 + (Math.random() - 0.5) * 8;
              const vx = (Math.random() - 0.5) * 140;
              const vy = -80 - Math.random() * 60;
              particles.push({
                  x, y, vx, vy,
                  life: 0.6 + Math.random() * 0.6,
                  a: 1,
                  size: 2 + Math.random() * 2,
                  color: 'rgba(255,220,240,1)'
              });
          }
      });
  }

  function spawnPieceBurst(p) {
      const cellSize = CELL;
      p.matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (!v) return;
              const cx = (p.pos.x + x) * cellSize + cellSize / 2;
              const cy = (p.pos.y + y) * cellSize + cellSize / 2;
              for (let i = 0; i < 3; i++) {
                  const ang = Math.random() * Math.PI * 2;
                  const sp = 80 + Math.random() * 120;
                  particles.push({
                      x: cx, y: cy,
                      vx: Math.cos(ang) * sp,
                      vy: Math.sin(ang) * sp,
                      life: 0.35 + Math.random() * 0.4,
                      a: 1,
                      size: 2 + Math.random() * 2,
                      color: 'rgba(255,90,110,1)'
                  });
              }
          });
      });
  }

  function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= dt;
          if (p.life <= 0) { particles.splice(i, 1); continue; }
          p.vy += 260 * dt; // gravity
          p.x += p.vx * dt;
          p.y += p.vy * dt;
      }
  }

  function drawParticles() {
      if (!particles.length) return;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      particles.forEach(p => {
          const alpha = Math.max(0, Math.min(1, p.life));
          ctx.fillStyle = p.color.replace(',1)', `,${alpha})`);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
      });
      ctx.restore();
  }

  // Next-piece preview support
  let nextPiece = null;

  function drawNext() {
      // clear preview
      nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      // subtle bg
      nctx.fillStyle = 'rgba(10,12,22,0.8)';
      nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

      if (!nextPiece) return;
      const matrix = nextPiece;
      const cell = CELL;
      const offsetX = Math.floor((nextCanvas.width - matrix[0].length * cell) / 2);
      const offsetY = Math.floor((nextCanvas.height - matrix.length * cell) / 2);

      matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) {
                  const color = colors[v] || '#ffffff';
                  // draw simple cell in preview (lighter style)
                  nctx.fillStyle = color;
                  nctx.fillRect(offsetX + x*cell, offsetY + y*cell, cell, cell);
                  // small glossy overlay
                  const g = nctx.createLinearGradient(offsetX + x*cell, offsetY + y*cell, offsetX + x*cell, offsetY + y*cell + cell);
                  g.addColorStop(0, 'rgba(255,255,255,0.22)');
                  g.addColorStop(0.4, 'rgba(255,255,255,0.06)');
                  g.addColorStop(1, 'rgba(0,0,0,0.18)');
                  nctx.fillStyle = g;
                  nctx.fillRect(offsetX + x*cell, offsetY + y*cell, cell, cell);
                  // border
                  nctx.strokeStyle = 'rgba(0,0,0,0.5)';
                  nctx.lineWidth = 1;
                  nctx.strokeRect(offsetX + x*cell + 0.5, offsetY + y*cell + 0.5, cell-1, cell-1);
              }
          });
      });
  }

  function draw() {
      // Background + grid
      drawBackground(nowMs);
      drawGrid();

      // Arena
      drawMatrix(arena, { x: 0, y: 0 });

      // Ghost + active piece (only when not flashing and game started)
      if (gameStarted && !flashingRows.length) {
          const gy = getGhostY();
          drawMatrix(player.matrix, { x: player.pos.x, y: gy }, { ghost: true });
          drawMatrix(player.matrix, player.pos);
      }

      // Pause overlay
      if (paused && !document.getElementById('startOverlay').classList.contains('hidden')) {
          // start overlay manages its own UI; nothing here
      } else if (paused && gameStarted) {
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#ffcad0';
          ctx.shadowColor = '#ff3040';
          ctx.shadowBlur = 14;
          ctx.font = 'bold 30px "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
          ctx.shadowBlur = 0;
      }

      // Flash rows that will be cleared
      if (flashingRows.length) {
          const on = Math.floor(flashElapsed / FLASH_INTERVAL) % 2 === 0;
          if (on) {
              ctx.save();
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = '#ffffff';
              for (const y of flashingRows) {
                  ctx.fillRect(0, y * CELL, canvas.width, CELL);
              }
              ctx.restore();
          }
      }

      // Particles last (over everything)
      drawParticles();

      // update next preview each frame (lightweight)
      drawNext();
  }

  function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;
      nowMs = time;

      const dt = delta / 1000;
      updateParticles(dt);

      if (!paused) {
          if (flashingRows.length) {
              flashElapsed += delta;
              if (flashElapsed >= FLASH_DURATION) {
                  flashingRows = [];
                  arenaSweep();
                  playerReset();
              }
          } else {
              dropCounter += delta;
              const baseInterval = 1000;
              const speedInterval = Math.max(120, baseInterval / gameMode.speed);
              if (dropCounter > speedInterval) playerDrop();
          }
      }

      draw();
      requestAnimationFrame(update);
  }

  function updateScore() {
      document.getElementById('score').textContent = player.score;
  }

  document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();

      // Ignore inputs during line-flash except Esc
      if (flashingRows.length && k !== 'escape') {
          e.preventDefault();
          return;
      }

      // When paused, only allow pause toggle and escape
      if (paused && k !== 'p' && k !== 'escape') {
          e.preventDefault();
          return;
      }

      if (k === 'a') { e.preventDefault(); playerMove(-1); }
      else if (k === 'd') { e.preventDefault(); playerMove(1); }
      else if (k === 's') { e.preventDefault(); playerDrop(); }
      else if (k === 'r') { e.preventDefault(); playerRotate(1); }
      else if (k === ' ') { e.preventDefault(); hardDrop(); }
      else if (k === 'm') {
          e.preventDefault();
          arena.forEach(row => row.fill(0));
          player.score = 0;
          playerReset(); updateScore();
      }
      else if (k === 'p') { e.preventDefault(); paused = !paused; }
      else if (k === 'escape') { window.location.href = 'index.html'; }
  });

  // Mobile buttons hook
  (function wireTouchControls(){
      const actions = {
          left: () => playerMove(-1),
          right: () => playerMove(1),
          rotate: () => playerRotate(1),
          soft: () => playerDrop(),
          hard: () => hardDrop(),
          pause: () => { paused = !paused; },
          restart: () => {
              arena.forEach(row => row.fill(0));
              player.score = 0;
              playerReset(); updateScore();
          },
          back: () => { window.location.href = 'index.html'; }
      };
      document.querySelectorAll('.touch-controls button').forEach(btn => {
          btn.addEventListener('click', () => {
              const act = btn.getAttribute('data-action');
              // Ignore touch actions during flash except Back
              if (flashingRows.length && act !== 'back') return;
              // When paused, only allow pause toggle and back
              if (paused && act !== 'pause' && act !== 'back') return;
              if (actions[act]) actions[act]();
          }, { passive: true });
      });
  })();

  // initial queue setup
  (function initNext(){
      const pieces = 'TJLOSZI';
      nextPiece = createPiece(pieces[(pieces.length * Math.random()) | 0]);
  })();

  // UI helpers
  const startOverlay = document.getElementById('startOverlay');
  const endOverlay = document.getElementById('endOverlay');
  const finalScoreEl = document.getElementById('finalScore');

  function showStartScreen() {
      paused = true;
      gameStarted = false;
      startOverlay.style.display = 'grid';
      startOverlay.setAttribute('aria-hidden','false');
      endOverlay.style.display = 'none';
      endOverlay.setAttribute('aria-hidden','true');
  }
  function hideStartScreen() {
      startOverlay.style.display = 'none';
      startOverlay.setAttribute('aria-hidden','true');
  }
  function showEndScreen() {
      paused = true;
      gameStarted = false;
      finalScoreEl.textContent = player.score;
      endOverlay.style.display = 'grid';
      endOverlay.setAttribute('aria-hidden','false');
  }
  function hideEndScreen() {
      endOverlay.style.display = 'none';
      endOverlay.setAttribute('aria-hidden','true');
  }

  // apply chosen mode: resize canvases and reset state
  function applyMode(modeKey) {
      gameMode = modes[modeKey] || modes.classic;
      CELL = Math.round(24 * gameMode.scale);

      // resize main canvas to logical pixels
      canvas.width = COLS * CELL;
      canvas.height = ROWS * CELL;
      // preserve CSS visual size; context will draw at new resolution
      ctx = canvas.getContext('2d');

      // preview canvas: use 4x cells
      nextCanvas.width = CELL * 4;
      nextCanvas.height = CELL * 4;
      nctx = nextCanvas.getContext('2d');

      // clear world and reset score
      arena.forEach(row => row.fill(0));
      player.score = 0;
      particles.length = 0;
      nextPiece = null;
      initNext();
      playerReset();
      updateScore();
  }

  // wire start mode buttons
  document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
      btn.addEventListener('click', () => {
          const mode = btn.getAttribute('data-mode');
          hideStartScreen();
          applyMode(mode);
          paused = false;
          gameStarted = true;
      });
  });

  // Play Again -> go back to start screen
  document.getElementById('playAgain').addEventListener('click', () => {
      hideEndScreen();
      showStartScreen();
  });

  // show start on load
  showStartScreen();
  update(); // start rendering loop (paused until mode chosen)
  updateScore();
</script>
</body>
</html>
