<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Tetris</title>
    <style>
        :root {
            --bg: linear-gradient(135deg, #0a0a14 0%, #1a0a2e 100%);
            --panel: rgba(21, 21, 31, 0.6);
            --fg: #fff;
            --accent: #ff3060;
            --accent-glow: rgba(255, 48, 96, 0.4);
        }
        html, body {
            height: 100%;
            margin: 0;
            background: #0a0a14;
            color: var(--fg);
            font-family: "Courier New", monospace;
        }
        body {
            background: linear-gradient(135deg, #0a0a14 0%, #1a0a2e 50%, #0a0a14 100%);
            background-attachment: fixed;
        }
        .wrap {
            min-height: 100%;
            display: grid;
            place-items: center;
            padding: 20px;
        }
        .game {
            background: var(--panel);
            backdrop-filter: blur(10px);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            display: grid;
            grid-template-columns: auto 180px;
            gap: 20px;
            box-shadow: 0 8px 32px rgba(255, 48, 96, 0.2), 
                        0 0 60px rgba(255, 48, 96, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease;
        }
        .game:hover {
            transform: translateY(-2px);
        }
        canvas {
            background: linear-gradient(180deg, #000000 0%, #0a0514 100%);
            image-rendering: pixelated;
            width: min(90vw, 360px);
            height: calc(min(90vw, 360px) * 2);
            max-width: 360px;
            max-height: 720px;
            border-radius: 8px;
            box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.8),
                        0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .side {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 160px;
        }
        .info {
            border: 1px solid rgba(255, 48, 96, 0.3);
            padding: 12px;
            border-radius: 8px;
            background: rgba(13, 13, 20, 0.7);
            backdrop-filter: blur(5px);
            font-size: 14px;
            line-height: 1.6;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        .info:hover {
            border-color: rgba(255, 48, 96, 0.6);
            box-shadow: 0 4px 20px rgba(255, 48, 96, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        .title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 16px;
            text-shadow: 0 0 10px var(--accent-glow);
        }
        .info > div:not(.title) {
            transition: transform 0.2s ease;
        }
        .info > div:not(.title):hover {
            transform: translateX(3px);
        }
        .btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        a.btn {
            color: #08080f;
            background: linear-gradient(135deg, var(--accent) 0%, #ff4070 100%);
            text-decoration: none;
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 48, 96, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        a.btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }
        a.btn:hover::before {
            left: 100%;
        }
        a.btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 48, 96, 0.5);
        }
        .muted { opacity: 0.6; }
        @media (max-width: 640px) {
            .game { grid-template-columns: 1fr; }
            .side { order: -1; }
        }

        /* Mobile controls */
        .touch-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        .touch-controls .row {
            display: contents;
        }
        .touch-controls button {
            background: linear-gradient(135deg, var(--accent) 0%, #ff4070 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 12px;
            font-weight: bold;
            font-family: "Courier New", monospace;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 4px 12px rgba(255, 48, 96, 0.3);
            transition: all 0.2s ease;
            font-size: 14px;
        }
        .touch-controls button:active { 
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(255, 48, 96, 0.4);
        }
        @media (max-width: 640px) {
            .touch-controls { display: grid; }
        }

        @keyframes scoreUpdate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); color: var(--accent); }
        }
        .score-update {
            animation: scoreUpdate 0.3s ease;
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="game">
        <canvas id="tetris" width="240" height="480" aria-label="Tetris board"></canvas>
        <div class="side">
            <div class="info">
                <div class="title">◆ TETRIS ◆</div>
                <div>Score: <span id="score">0</span></div>
                <div>Lines: <span id="lines">0</span></div>
                <div>Level: <span id="level">0</span></div>
            </div>
            <div class="info">
                <div class="title">⌨ Controls</div>
                <div>A: Move left</div>
                <div>D: Move right</div>
                <div>R: Rotate</div>
                <div>S: Soft drop</div>
                <div>Space: Hard drop</div>
                <div>M: Restart</div>
                <div>P: Pause</div>
                <div class="muted">Esc: Back</div>
            </div>

            <!-- Mobile controls -->
            <div class="touch-controls" aria-label="Mobile Controls">
                <div class="row">
                    <button data-action="left">←</button>
                    <button data-action="rotate">⟳</button>
                    <button data-action="right">→</button>
                </div>
                <div class="row">
                    <button data-action="soft">Soft</button>
                    <button data-action="hard">Hard</button>
                    <button data-action="pause">Pause</button>
                </div>
                <div class="row">
                    <button data-action="restart">Restart</button>
                    <button data-action="back">Back</button>
                    <span></span>
                </div>
            </div>

            <div class="btns">
                <a class="btn" href="index.html">← Back</a>
            </div>
        </div>
    </div>
</div>

<script>
  // admin guard: redirect to index if not admin
  // launch-token guard: only allow if launched from terminal (short-lived token)
  (function(){
    try {
      const params = new URLSearchParams(window.location.search);
      const token = params.get('lt');
      const stored = sessionStorage.getItem('alpha_launch_token');
      const expiry = parseInt(sessionStorage.getItem('alpha_launch_expiry') || '0', 10);
      if (!token || !stored || token !== stored || Date.now() > expiry) {
        alert('Access denied. Game must be launched from the terminal.');
        window.location.href = 'index.html';
        return;
      }
      // consume token and clean URL
      sessionStorage.removeItem('alpha_launch_token');
      sessionStorage.removeItem('alpha_launch_expiry');
      const url = new URL(window.location);
      url.searchParams.delete('lt');
      window.history.replaceState({}, '', url.pathname + url.search + url.hash);
    } catch(e) {
      window.location.href = 'index.html';
      return;
    }
  })();

  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');

  const COLS = 10, ROWS = 20, SIZE = 24;
  ctx.scale(SIZE/24, SIZE/24);

  // Particle system for line clear effects
  const particles = [];
  
  class Particle {
      constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 4;
          this.vy = (Math.random() - 0.5) * 4 - 2;
          this.life = 1.0;
          this.color = color;
          this.size = Math.random() * 3 + 2;
      }
      
      update(delta) {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.15; // gravity
          this.life -= delta / 500;
      }
      
      draw(ctx) {
          ctx.save();
          ctx.globalAlpha = this.life;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
      }
  }

  function createMatrix(w, h) {
      const m = [];
      while (h--) m.push(new Array(w).fill(0));
      return m;
  }

  function createPiece(type) {
      switch (type) {
          case 'T': return [
              [0,1,0],
              [1,1,1],
              [0,0,0],
          ];
          case 'O': return [
              [2,2],
              [2,2],
          ];
          case 'L': return [
              [0,0,3],
              [3,3,3],
              [0,0,0],
          ];
          case 'J': return [
              [4,0,0],
              [4,4,4],
              [0,0,0],
          ];
          case 'I': return [
              [0,0,0,0],
              [5,5,5,5],
              [0,0,0,0],
              [0,0,0,0],
          ];
          case 'S': return [
              [0,6,6],
              [6,6,0],
              [0,0,0],
          ];
          case 'Z': return [
              [7,7,0],
              [0,7,7],
              [0,0,0],
          ];
      }
  }

  const colors = [
      null,
      '#a000f0', // T - purple
      '#f0f000', // O - yellow
      '#f0a000', // L - orange
      '#0000f0', // J - blue
      '#00f0f0', // I - cyan
      '#00f000', // S - green
      '#f00000', // Z - red
  ];

  const colorGradients = [
      null,
      ['#c040ff', '#8000d0'], // T
      ['#ffff40', '#d0d000'], // O
      ['#ffc040', '#d08000'], // L
      ['#4040ff', '#0000d0'], // J
      ['#40ffff', '#00d0d0'], // I
      ['#40ff40', '#00d000'], // S
      ['#ff4040', '#d00000'], // Z
  ];

  const arena = createMatrix(COLS, ROWS);

  const player = {
      pos: { x: 0, y: 0 },
      matrix: null,
      score: 0,
      lines: 0,
      level: 0,
  };

  let dropCounter = 0;
  let lastTime = 0;
  let paused = false;

  let flashingRows = [];
  let flashElapsed = 0;
  const FLASH_DURATION = 400;
  const FLASH_INTERVAL = 80;

  // Placement animation
  let placementAnim = 0;
  const PLACEMENT_DURATION = 150;

  function collide(arena, player) {
      const m = player.matrix;
      const o = player.pos;
      for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
              if (m[y][x] !== 0 &&
                  (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  function collideAt(matrix, pos) {
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < matrix[y].length; ++x) {
              if (matrix[y][x] !== 0 &&
                  (arena[y + pos.y] && arena[y + pos.y][x + pos.x]) !== 0) {
                  return true;
              }
          }
      }
      return false;
  }

  function merge(arena, player) {
      player.matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) arena[y + player.pos.y][x + player.pos.x] = v;
          });
      });
  }

  function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < y; ++x) {
              [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
          }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
  }

  function playerReset() {
      const pieces = 'TJLOSZI';
      player.matrix = createPiece(pieces[(pieces.length * Math.random()) | 0]);
      player.pos.y = 0;
      player.pos.x = ((COLS / 2) | 0) - ((player.matrix[0].length / 2) | 0);
      if (collide(arena, player)) {
          arena.forEach(row => row.fill(0));
          player.score = 0;
          player.lines = 0;
          player.level = 0;
          updateScore();
      }
  }

  function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
  }

  function getFullRows() {
      const rows = [];
      for (let y = 0; y < arena.length; ++y) {
          let full = true;
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) { full = false; break; }
          }
          if (full) rows.push(y);
      }
      return rows;
  }

  function createParticlesForRows(rows) {
      rows.forEach(y => {
          for (let x = 0; x < COLS; x++) {
              const colorIdx = arena[y][x];
              if (colorIdx !== 0) {
                  for (let i = 0; i < 3; i++) {
                      particles.push(new Particle(
                          x * 24 + 12,
                          y * 24 + 12,
                          colors[colorIdx]
                      ));
                  }
              }
          }
      });
  }

  function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          const rows = getFullRows();
          if (rows.length) {
              flashingRows = rows;
              flashElapsed = 0;
              createParticlesForRows(rows);
          } else {
              placementAnim = PLACEMENT_DURATION;
              setTimeout(() => playerReset(), PLACEMENT_DURATION);
          }
      }
      dropCounter = 0;
  }

  function hardDrop() {
      do {
          player.pos.y++;
      } while (!collide(arena, player));
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      placementAnim = PLACEMENT_DURATION;
      setTimeout(() => playerReset(), PLACEMENT_DURATION / 2);
      dropCounter = 0;
  }

  function playerRotate(dir) {
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > player.matrix[0].length) {
              rotate(player.matrix, -dir);
              player.pos.x = pos;
              return;
          }
      }
  }

  function arenaSweep() {
      let rowCount = 1;
      outer: for (let y = arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) continue outer;
          }
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          player.score += rowCount * 100;
          player.lines += 1;
          if (player.lines % 10 === 0) player.level++;
          rowCount *= 2;
      }
      updateScore();
  }

  function drawBlock(x, y, colorIdx) {
      const px = x * 24;
      const py = y * 24;
      
      // Main gradient
      const grad = ctx.createLinearGradient(px, py, px + 24, py + 24);
      grad.addColorStop(0, colorGradients[colorIdx][0]);
      grad.addColorStop(1, colorGradients[colorIdx][1]);
      ctx.fillStyle = grad;
      ctx.fillRect(px, py, 24, 24);
      
      // Highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(px + 1, py + 1, 22, 8);
      
      // Border with glow
      ctx.strokeStyle = colorGradients[colorIdx][1];
      ctx.lineWidth = 1;
      ctx.strokeRect(px + 0.5, py + 0.5, 23, 23);
      
      // Inner border
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.strokeRect(px + 2.5, py + 2.5, 19, 19);
  }

  function drawMatrix(matrix, offset, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      matrix.forEach((row, y) => {
          row.forEach((v, x) => {
              if (v !== 0) {
                  drawBlock(x + offset.x, y + offset.y, v);
              }
          });
      });
      ctx.restore();
  }

  function getGhostY() {
      let y = player.pos.y;
      while (!collideAt(player.matrix, { x: player.pos.x, y: y + 1 })) {
          y++;
      }
      return y;
  }

  function draw() {
      // Background gradient
      const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bgGrad.addColorStop(0, '#000000');
      bgGrad.addColorStop(1, '#0a0514');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Grid pattern
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * 24, 0);
          ctx.lineTo(x * 24, canvas.height);
          ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * 24);
          ctx.lineTo(canvas.width, y * 24);
          ctx.stroke();
      }
      
      drawMatrix(arena, { x: 0, y: 0 });

      // Update and draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
          if (particles[i].life <= 0) {
              particles.splice(i, 1);
          } else {
              particles[i].draw(ctx);
          }
      }

      if (!flashingRows.length && placementAnim === 0) {
          const gy = getGhostY();
          drawMatrix(player.matrix, { x: player.pos.x, y: gy }, 0.15);
          drawMatrix(player.matrix, player.pos);
      }

      if (paused) {
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Animated pause text
          ctx.save();
          ctx.shadowColor = 'rgba(255, 48, 96, 0.8)';
          ctx.shadowBlur = 20;
          ctx.fillStyle = '#ff3060';
          ctx.font = 'bold 32px "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('❚❚ PAUSED', canvas.width / 2, canvas.height / 2 - 10);
          ctx.restore();
          
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.font = '14px "Courier New", monospace';
          ctx.fillText('Press P to resume', canvas.width / 2, canvas.height / 2 + 20);
      }

      if (flashingRows.length) {
          const progress = flashElapsed / FLASH_DURATION;
          const on = Math.floor(flashElapsed / FLASH_INTERVAL) % 2 === 0;
          
          ctx.save();
          for (const y of flashingRows) {
              if (on) {
                  const grad = ctx.createLinearGradient(0, y * 24, canvas.width, y * 24);
                  grad.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                  grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                  grad.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                  ctx.fillStyle = grad;
              } else {
                  ctx.fillStyle = 'rgba(255, 100, 150, 0.5)';
              }
              ctx.fillRect(0, y * 24, canvas.width, 24);
              
              // Glow effect
              ctx.shadowColor = 'rgba(255, 48, 96, 0.8)';
              ctx.shadowBlur = 15;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
              ctx.lineWidth = 2;
              ctx.strokeRect(0, y * 24, canvas.width, 24);
          }
          ctx.restore();
      }
  }

  function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;

      // Update particles
      particles.forEach(p => p.update(delta));

      if (!paused) {
          if (placementAnim > 0) {
              placementAnim = Math.max(0, placementAnim - delta);
          } else if (flashingRows.length) {
              flashElapsed += delta;
              if (flashElapsed >= FLASH_DURATION) {
                  flashingRows = [];
                  arenaSweep();
                  playerReset();
              }
          } else {
              dropCounter += delta;
              const speed = Math.max(120, 1000 - player.level * 75);
              if (dropCounter > speed) playerDrop();
          }
      }

      draw();
      requestAnimationFrame(update);
  }

  function updateScore() {
      const scoreEl = document.getElementById('score');
      const linesEl = document.getElementById('lines');
      const levelEl = document.getElementById('level');
      
      scoreEl.textContent = player.score;
      linesEl.textContent = player.lines;
      levelEl.textContent = player.level;
      
      // Animate score update
      scoreEl.classList.add('score-update');
      setTimeout(() => scoreEl.classList.remove('score-update'), 300);
  }

  document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();

      if (flashingRows.length && k !== 'escape') {
          e.preventDefault();
          return;
      }

      if (paused && k !== 'p' && k !== 'escape') {
          e.preventDefault();
          return;
      }

      if (k === 'a') { e.preventDefault(); playerMove(-1); }
      else if (k === 'd') { e.preventDefault(); playerMove(1); }
      else if (k === 's') { e.preventDefault(); playerDrop(); }
      else if (k === 'r') { e.preventDefault(); playerRotate(1); }
      else if (k === ' ') { e.preventDefault(); hardDrop(); }
      else if (k === 'm') {
          e.preventDefault();
          arena.forEach(row => row.fill(0));
          player.score = 0; player.lines = 0; player.level = 0;
          playerReset(); updateScore();
      }
      else if (k === 'p') { e.preventDefault(); paused = !paused; }
      else if (k === 'escape') { window.location.href = 'index.html'; }
  });

  (function wireTouchControls(){
      const actions = {
          left: () => playerMove(-1),
          right: () => playerMove(1),
          rotate: () => playerRotate(1),
          soft: () => playerDrop(),
          hard: () => hardDrop(),
          pause: () => { paused = !paused; },
          restart: () => {
              arena.forEach(row => row.fill(0));
              player.score = 0; player.lines = 0; player.level = 0;
              playerReset(); updateScore();
          },
          back: () => { window.location.href = 'index.html'; }
      };
      document.querySelectorAll('.touch-controls button').forEach(btn => {
          btn.addEventListener('click', () => {
              const act = btn.getAttribute('data-action');
              if (flashingRows.length && act !== 'back') return;
              if (paused && act !== 'pause' && act !== 'back') return;
              if (actions[act]) actions[act]();
          }, { passive: true });
      });
  })();

  playerReset();
  updateScore();
  update();
</script>
</body>
</html>
